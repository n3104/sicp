#lang planet neil/sicp

(#%require (only racket include))
(include "./ch5-regsim.rkt")
(set! make-stack make-stack-with-monitor)

(include "./ch5-syntax.rkt")
(include "./ch5-eceval-support.rkt")

(define (lexical-address-lookup address env)
  (define (lookup-frame frame-number env)
    (define (frame-itr counter env)
      (if (eq? env the-empty-environment)
          (error "Unbound variable" address)
          (let ((frame (first-frame env)))
            (if (eq? counter frame-number)
                frame
                (frame-itr (+ counter 1) (enclosing-environment env))))))
    (frame-itr 0 env))
  (define (lookup-value displacement-number frame)
    ; 変位数は変数がフレームに追加された順番になっているが、実際に探索する際は最後に追加された変数から探索するためインデックスを反転している。
    (let ((reversed-displacement-number (- (length (frame-variables frame)) displacement-number 1)))
      (define (variable-itr counter vars vals)
        (cond ((null? vars)
               (error "Unbound variable" address))
              ((eq? counter reversed-displacement-number)
               (let ((value (car vals)))
                 (if (eq? value '*unassigned*)
                     (error "Unbound variable" address)
                     value)))
              (else
               (variable-itr (+ counter 1) (cdr vars) (cdr vals)))))
      (variable-itr 0 (frame-variables frame) (frame-values frame))))
  (let ((frame-number (car address)) (displacement-number (cadr address)))
    (let ((frame (lookup-frame frame-number env)))
      (lookup-value displacement-number frame))))

(define (lexical-address-set! address val env)
  (define (lookup-frame frame-number env)
    (define (frame-itr counter env)
      (if (eq? env the-empty-environment)
          (error "Unbound variable" address)
          (let ((frame (first-frame env)))
            (if (eq? counter frame-number)
                frame
                (frame-itr (+ counter 1) (enclosing-environment env))))))
    (frame-itr 0 env))
  (define (set-value displacement-number frame)
    (let ((reversed-displacement-number (- (length (frame-variables frame)) displacement-number 1)))
      (define (variable-itr counter vars vals)
        (cond ((null? vars)
               (error "Unbound variable" address))
              ((eq? counter reversed-displacement-number)
               (set-car! vals val))
              (else
               (variable-itr (+ counter 1) (cdr vars) (cdr vals)))))
      (variable-itr 0 (frame-variables frame) (frame-values frame))))
  (let ((frame-number (car address)) (displacement-number (cadr address)))
    (let ((frame (lookup-frame frame-number env)))
      (set-value displacement-number frame))))

(#%require (only rackunit check-equal?))
(define frame-a (extend-environment '() '() the-empty-environment))
(define-variable! 'a 1 frame-a)
(define-variable! 'b 2 frame-a)
(define-variable! 'c 3 frame-a)

(check-equal? (lookup-variable-value 'a frame-a) 1)
(check-equal? (lookup-variable-value 'b frame-a) 2)
(check-equal? (lookup-variable-value 'c frame-a) 3)

(check-equal? (lexical-address-lookup '(0 0) frame-a) 1)
(check-equal? (lexical-address-lookup '(0 1) frame-a) 2)
(check-equal? (lexical-address-lookup '(0 2) frame-a) 3)